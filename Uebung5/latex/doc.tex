\documentclass{report}
\usepackage{pdfpages}
\usepackage[a4paper, top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx} 
\usepackage{ulem}
\usepackage{listings}
\usepackage[absolute,overlay]{textpos}
\usepackage{minted}

\lstdefinestyle{cppstyle}{
	language=C++,             % Specify the language
	basicstyle=\ttfamily,     % Set the font to typewriter
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\color{blue}\bfseries, % Keywords in bold blue
	commentstyle=\color{green},         % Comments in green
	stringstyle=\color{red},            % Strings in red
	numbers=left,            % Line numbers on the left
	numberstyle=\tiny\color{gray}, % Line numbers in tiny gray font
	stepnumber=1,             % Line number step
	breaklines=true,          % Automatic line breaking
	tabsize=4,                % Set tab size
	showstringspaces=false,   % Don't show spaces in strings
	frame=single,             % Add a frame around the code
}

\newcommand{\name}{Marco Söllinger,}
\newcommand{\fach}{SEN2}
\newcommand{\topic}{Übung 1}
\newcommand{\uebungangabe}{Uebung1.pdf}

\newcommand{\matnr}{s2410306011, Gruppe 1}
\newcommand{\uebungsgruppe}{Gruppe 2}
\newcommand{\aufwand}{4}


\pagestyle{fancy}
\normalem 
\fancyhead[R]{Marco Söllinger}  

\begin{document}
\includepdf[pages=1,pagecommand={
			\begin{textblock*}{10cm}(3.5cm, 3.1cm)
				\textbf{\name}    \textbf{\matnr}
			\end{textblock*}
		}]{./MPT3_Uebung_3.pdf}

\section*{Aufgabe 1:}

\subsection*{1.1 Loesungsidee}
Das Blinklicht auf LED3 wird mit dem Timer TIM3 im Update-Interrupt bei 5\,Hz realisiert.\\
Es ist keine Implementierung mittels PWM 
Die Taster USER0 und USER1 werden ueber EXTI-Interrupts (Linien 0 und 1) ausgewertet, welche das Starten bzw.\ Stoppen des Timers sowie das Toggeln der LEDs 4 und 5 uebernehmen.\\
Die Initialisierung von LEDs, Tastern, Timer und EXTI erfolgt in der main.c unter Verwendung der gegebenen Board-Treiber.


\subsection*{1.2 Code}
Die Board treiber wurden nicht veraendert und sind in den Board Unterordnern zu finden.\\

\lstinputlisting[style=cppstyle, title=\texttt{main.c} ]{../STM32Base/projects/Alarmanlage/main.c}

Frage Prioritate reference manuel seite 218 niedrige Priorität ist wichtiger wird also vorher aufgrerufen

\subsection*{1.3 Fragen}
\subsection*{1.\ PWM-Signal mit Timer erzeugen}

Ein PWM-Signal wird beim STM32 (z.\,B. STM32F0) typischerweise mit einem
Allzweck-Timer (\verb|TIMx|) im Output-Compare-/PWM-Modus erzeugt. Die Grundidee:

\begin{itemize}
  \item Der Timer zählt von \verb|0| bis \verb|ARR| (Auto-Reload-Register).
  \item Die PWM-Periode wird durch \verb|PSC| (Prescaler) und \verb|ARR| bestimmt.
  \item Das Tastverhältnis (Duty-Cycle) wird durch \verb|CCRn| (Capture/Compare-Register)
        des gewählten Kanals eingestellt.
  \item Über die PWM-Mode-Einstellungen in \verb|CCMRx| und das Enable-Bit in \verb|CCER|
        wird das Signal auf einen GPIO-Pin ausgegeben.
\end{itemize}

\paragraph{Schritt-für-Schritt-Vorgehen}

\subsubsection*{1.\ Takt für Timer und GPIO einschalten}

\begin{itemize}
  \item Im Reset-Zustand sind Timer und Ports ggf. noch nicht getaktet.
  \item Über die RCC-Register (z.\,B.\ \verb|RCC->APB1ENR| oder \verb|RCC->APB2ENR|)
        wird der Timer-Takt aktiviert, z.\,B.:
        \[
          \verb|RCC->APB1ENR |= \dots | \verb|RCC_APB1ENR_TIM3EN|
        \]
  \item Der zugehörige GPIO-Pin wird per \verb|RCC->AHBENR| getaktet.
\end{itemize}

\subsubsection*{2.\ GPIO-Pin als Alternate Function konfigurieren}

\begin{itemize}
  \item Den gewünschten Timerkanal (z.\,B.\ TIM3\_CH1) auf einen Port-Pin mappen:
        \begin{itemize}
          \item \verb|MODER|: Pin auf Alternate Function (\verb|10|) setzen.
          \item \verb|AFR[0/1]|: passende Alternate-Function-Nummer eintragen (AF1, AF2, \dots).
          \item \verb|OTYPER|, \verb|OSPEEDR|, \verb|PUPDR| je nach Bedarf.
        \end{itemize}
\end{itemize}

\subsubsection*{3.\ Timer-Basis konfigurieren (Periode / Frequenz)}

\begin{itemize}
  \item Prescaler (\verb|PSC|) und Auto-Reload (\verb|ARR|) bestimmen die Timerfrequenz.
  \item Timer-Takt:
  \[
    f_{\text{TIM}} = \frac{f_{\text{APB}}}{(\verb|PSC|+1)}
  \]
  \item PWM-Frequenz:
  \[
    f_{\text{PWM}} = \frac{f_{\text{TIM}}}{(\verb|ARR|+1)}
    = \frac{f_{\text{APB}}}{(\verb|PSC|+1)\,(\verb|ARR|+1)}
  \]
  \item Dazu:
  \begin{verbatim}
TIMx->PSC = ...;   // Prescaler
TIMx->ARR = ...;   // Periodenwert
  \end{verbatim}
  \item Optional: \verb|TIMx->CR1 |= TIM_CR1_ARPE;  % Auto-Reload Preload Enable
\end{itemize}

\subsubsection*{4.\ Duty-Cycle über Capture/Compare-Register einstellen}

\begin{itemize}
  \item Jeder Kanal hat ein \verb|CCRn|-Register (\verb|CCR1|, \verb|CCR2|, ...).
  \item Für PWM gilt:
  \[
    D = \frac{\verb|CCRn|}{\verb|ARR| + 1}
  \]
  \item Beispiel:
  \begin{itemize}
    \item \verb|CCR1 = 0|  \(\Rightarrow\) 0\,\% Duty-Cycle (immer aus)
    \item \verb|CCR1 = ARR/2| \(\Rightarrow\) ca. 50\,\%
    \item \verb|CCR1 = ARR|   \(\Rightarrow\) fast 100\,\%
  \end{itemize}
\end{itemize}

\subsubsection*{5.\ PWM-Modus im Compare-Register aktivieren}

\begin{itemize}
  \item Die PWM-Konfiguration erfolgt im Capture/Compare Mode Register \verb|CCMRx|.
  \item Für Kanal~1 und 2: \verb|CCMR1|, für Kanal~3 und 4: \verb|CCMR2|.
  \item Relevante Bits (Kanal~1 als Beispiel in \verb|CCMR1|):
        \begin{itemize}
          \item \verb|OC1M[2:0]|: Output Compare Mode
                \begin{itemize}
                  \item \verb|110| = PWM mode 1
                  \item \verb|111| = PWM mode 2
                \end{itemize}
          \item \verb|OC1PE|: Output Compare Preload Enable (für gepufferte CCR-Updates)
        \end{itemize}
  \item Beispiel (logisch):
  \begin{verbatim}
TIMx->CCMR1 &= ~TIM_CCMR1_OC1M;
TIMx->CCMR1 |= (6 << TIM_CCMR1_OC1M_Pos); // PWM mode 1
TIMx->CCMR1 |= TIM_CCMR1_OC1PE;           // Preload
  \end{verbatim}
\end{itemize}

\subsubsection*{6.\ Kanal-Ausgang einschalten}

\begin{itemize}
  \item Im \verb|CCER|-Register wird der Kanal aktiviert:
        \begin{itemize}
          \item \verb|CC1E|: Output Enable (1 = an)
          \item \verb|CC1P|: Polarität (0 = aktiv high, 1 = aktiv low)
        \end{itemize}
  \item Beispiel:
  \begin{verbatim}
TIMx->CCER |= TIM_CCER_CC1E;  // Kanal 1 aktivieren
// ggf. Polarität
// TIMx->CCER &= ~TIM_CCER_CC1P; // aktiv high
  \end{verbatim}
\end{itemize}

\subsubsection*{7.\ Timer starten (und ggf. Main Output Enable)}

\begin{itemize}
  \item Timerzählung starten:
  \begin{verbatim}
TIMx->CR1 |= TIM_CR1_CEN;
  \end{verbatim}
  \item Bei Advanced-Control-Timern (z.\,B.\ TIM1) zusätzlich:
  \begin{itemize}
    \item \verb|BDTR.MOE| (Main Output Enable) setzen:
    \begin{verbatim}
TIM1->BDTR |= TIM_BDTR_MOE;
    \end{verbatim}
  \end{itemize}
\end{itemize}

Damit erzeugt der Timer ein kontinuierliches PWM-Signal am jeweiligen
Ausgangspin (z.\,B.\ \verb|TIM3_CH1| auf einem GPIO-Pin).


\subsection*{2.\ Priorität von Interrupts und Reihenfolge bei gleichzeitigen IRQs}

\subsubsection*{2.1 Festlegen der Interrupt-Prioritäten (2 Möglichkeiten)}

Beim Cortex-M (z.\,B.\ beim STM32F0) wird die Priorität von Interrupts
über den Nested Vectored Interrupt Controller (NVIC) festgelegt. Es gibt
zwei typische Möglichkeiten:

\begin{enumerate}
  \item \textbf{Über Software, durch Schreiben der NVIC-Prioritätsregister}
        \begin{itemize}
          \item Mit CMSIS-Funktion:
          \begin{verbatim}
NVIC_SetPriority(TIM7_IRQn,  1);  // niedrigere Zahl = höhere Priorität
NVIC_SetPriority(ADC1_IRQn,  2);
          \end{verbatim}
          \item Intern schreibt dies in \verb|NVIC->IP[x]| (Interrupt Priority Register).
          \item Je nach Core stehen nur wenige MSB-Bits pro Interrupt zur Verfügung
                (z.\,B.\ 2 Bits = 4 Prioritätsstufen).
        \end{itemize}

  \item \textbf{Über die Vektortabelle / Ausnahme-Nummern (feste Hardware-Priorität)}
        \begin{itemize}
          \item Jeder Interrupt hat eine feste Ausnahme-Nummer (Exception Number).
          \item System-Exceptions wie Reset, NMI, HardFault haben eine \emph{höhere}
                feste Priorität als alle externen IRQs.
          \item Bei gleichen NVIC-Prioritätswerten entscheidet die \emph{natürliche Priorität}
                gemäß Ausnahme-Nummer bzw. Position in der Vektortabelle:
                \begin{itemize}
                  \item Kleinere Exception-Nummer \(\Rightarrow\) höhere Priorität.
                \end{itemize}
        \end{itemize}
\end{enumerate}

(Man könnte auch sagen: eine Möglichkeit ist die explizite Konfiguration in \verb|NVIC->IP|,
die zweite ist die \emph{implizite} Priorität durch die feste Exception-Hierarchie.)

\subsubsection*{2.2 Welcher Interrupt läuft zuerst bei gleichzeitig anliegenden IRQs?}

Angenommen, zwei Interruptquellen (z.\,B.\ TIM7 und ADC) werden zur exakt
gleichen Zeit pending, dann gilt:

\begin{enumerate}
  \item Zuerst betrachtet der NVIC die \textbf{NVIC-Priorität} (den numerischen Wert,
        den man mit \verb|NVIC_SetPriority| gesetzt hat):
        \begin{itemize}
          \item Niedrigere Zahl bedeutet höhere Priorität.
          \item Beispiel:
          \begin{itemize}
            \item \verb|NVIC_SetPriority(TIM7_IRQn, 1);|
            \item \verb|NVIC_SetPriority(ADC1_IRQn, 2);|
          \end{itemize}
          \(\Rightarrow\) TIM7-Interrupt wird zuerst ausgeführt.
        \end{itemize}

  \item \textbf{Falls beide Interrupts exakt die gleiche Prioritätsstufe haben} (z.\,B.\ beide
        Priorität \verb|1|), dann entscheidet die \emph{natürliche Reihenfolge}:
        \begin{itemize}
          \item Der Interrupt mit der \emph{kleineren Exception-Nummer} (also weiter oben
                in der Vektortabelle) wird zuerst bedient.
          \item Konkret heißt das: Der Hardware-Designer (Datenblatt / Referenzmanual)
                legt fest, welcher IRQ eine höhere feste Priorität hat, wenn die
                NVIC-Priorität identisch ist.
        \end{itemize}
\end{enumerate}

Kurz zusammengefasst:

\begin{itemize}
  \item Priorität wird festgelegt
        \begin{enumerate}
          \item durch den in \verb|NVIC->IP| gesetzten Prioritätswert
                (z.\,B.\ per \verb|NVIC_SetPriority|), und
          \item durch die feste Reihenfolge (Exception-Nummer / Vektortabelle), falls
                der Prioritätswert gleich ist.
        \end{enumerate}
  \item Von zwei gleichzeitig anliegenden Interrupts wird also immer der mit
        \emph{höherer Priorität} (kleinerer NVIC-Prioritätszahl, bzw.\ bei Gleichstand
        kleinerer Exception-Nummer) zuerst ausgeführt.
\end{itemize}


\end{document}
